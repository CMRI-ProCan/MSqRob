---
title: "MSqRob Vignette"
author: "Ludger Goeminne, Kris Gevaert and Lieven Clement"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
fig_caption: yes
vignette: >
  %\VignetteIndexEntry{MSqRob Vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Introduction

The MSqRob package is designed for the analysis of differential abundance in label-free mass spectrometry-based shotgun proteomics experiments. These experiments typically output large spectral files (e.g. ".mzML" files) that need to be searched for identifications by specialized peak detection and peptide identification software such as Andromeda (used in the MaxQuant software package) and Mascot Distiller. These algorithms output lists of putative peptides accompanied by their corresponding overall intensity estimates.

Often, researchers further summarize these peptide intensities to protein intensities. However, as we have shown before, this summarization-based approaches tend to perform suboptimal compared to peptide-based models, wherein the peptide intensities are directly provided as input to the statistical model used for differential quantification (Goeminne et al., 2015). Nonetheless, most of these models still suffer from overfitting issues.

This package implements the robust ridge approach that prevents overfitting in sparse data but also accurately fits highly abundant proteins as described in Goeminne et al. (2016).

This vignette will guide you through the main features of the MSqRob package. We will highlight two examples in order to help you familiarize with its main features. MSqRob is completely free and open source, but please make a reference to Goeminne et al. (2016) when using our package in any kind of publication.

## Downloading, installing and loading MSqRob

##Installing the package

On Windows, make sure that RTools is installed. Go to: https://cran.r-project.org/bin/windows/Rtools/ to download RTools. A user guide on how to install RTools on Windows can be found at: https://github.com/stan-dev/rstan/wiki/Install-Rtools-for-Windows. Errors in MSqRob on Windows related to unable to zip the results Excel file might be related to errors in configuring RTools.

First, we need to install the package devtools:
```{r eval=FALSE}
install.packages("devtools")
library(devtools)
```

Then, we call this to install MSqRob from GitHub:

```{r eval=FALSE}
devtools::install_github("ludgergoeminne/MSqRob")
library(MSqRob)
```

Loading the package is done via the `library` command, as with any other package.
```{r eval=FALSE}
library(MSqRob)
```

##The Shiny App

```{r eval=FALSE}
shiny::runApp(system.file('App-MSqRob', package='MSqRob'))
```

##*Francisella tularensis* dataset (data-dependent, label-free)

The bacterium *Francisella tularensis* is a facultative intracellular parasite of macrophages and must import host cell arginine in order to be able to multiply inside the host cell. Ramond et al. (2015) investigated the effect of gene deletion of a newly identified arginine transporter called ArgP.
Their data is deposited in the PRIDE repository at http://www.ebi.ac.uk/pride/archive/projects/PXD001584. We used the authors' supplied peptides.txt file which is the result of preprocessing with MaxQuant version 1.4.1.2. As the authors used now outdated GI numbers, we modified this file to incorporate NCBI accessions and protein names (September 25, 2016).

###1. Importing data

First, specify the location of the peptides.txt MaxQuant output file.
By default, MaxQuant creates a "combined" folder in the same folder as the raw files are (or if the raw files are in different directories, in the directory of the first raw file). The peptides.txt file can then be found in "path_to_raw_files/combined/txt/peptides.txt". Just provide the path to where the file is located on your computer. The `system.file` function is used here only to access the example tab-delimited peptides.txt file that is delivered with our package. The `pattern` argument should contain a text string that is present in all column names that contain peptide intensities but not in the other column names. This defaults to `"Intensity."`.

```{r eval=FALSE}
file_peptides_txt <- system.file("extdata/Francisella", "peptides.txt", package = "MSqRob")
file_peptides_txt
```

Import the data using the `read_MaxQuant` function.
```{r eval=FALSE}
peptidesFranc <- read_MaxQuant(file_peptides_txt, pattern="Intensity.", remove_pattern=TRUE)
```

`read_MaxQuant` creates an `MSnSet` object with 3 slots:

- `exprs`: contains a matrix of peptide intensities of which the rows correspond to the peptides present in the dataset and the columns correspond to the different mass spec runs.

- `fData`: contains a data frame containing all additional information (such as peptide sequences, protein names, scores, number of missed cleavages, etc.) present in the input file.

- `pData`: contains a data frame with 0 columns and as many rows as there are mass spec runs. This slot will be used to store the experiment annotation.

If you want to assess whether importing happened in a correct way, you can always check the `exprs`, `fData` and `pData` slots.

The `exprs` slot should contain all the peptide intensities grouped per column.
```{r eval=FALSE}
head(exprs(peptidesFranc))
```

The `fData` slot contains all other columns.
```{r eval=FALSE}
head(fData(peptidesFranc))
```

The `pData` slot will contain the experimental annotation. Right now, it has 18 rows (equal to the number of mass spec runs) and 0 columns (as the experimental annotation is not yet loaded).
```{r eval=FALSE}
pData(peptidesFranc)
```

###2. Preprocessing

###2.1. Create experiment annotation data frame.

Now, we are going to create a data frame that contains the experimental annotation. This is important in order to be able to include factors on which you will want to do inference (such as treatment effects or effects over time; in our case: the effect of the genetic knock out) as well as other factors that might have an influence (such as biological repeats, technical repeats and potential confounders such as batch effects).

**Note that the "experiment annotation" can also be given as an Excel file or a tab delimited file!** This file should have the column names as a header (i.e. the first row in the file) and the same structure as the `exp_annotation` data frame we create below. If you have your experiment annotation in a file, just provide the filepath to this annotation file in the preprocess_MaxQuant function.

Also note that exactly one column in the experiment annotation should contain the names of the mass spec runs. These names should be equal to the "experiment names" you entered in MaxQuant (i.e. the column names of the `exprs` slot of the peptidesCPTAC `MSnSet` object). In our case, we will call this column "run" (see below). By default, MSqRob tries guesses this column by taking the only column of which its elements correspond to the column names of the `exprs` slot. If there is no such a column, or there are multiple such columns, MSqRob throws an error.

In this example, we create the experimental annotation data frame ourselves.

Extract the names of the mass spec runs. The mass spec run names are equal to the column names of the exprs slot of the peptidesCPTAC `MSnSet` object. Other columns in the experimental annotation data frame will typically be derived from this column.

```{r eval=FALSE}
library(Biobase)
runs <- Biobase::sampleNames(peptidesFranc)
runs
colnames(exprs(peptidesFranc))
```

Add a factor for the genetic knock out, which we will call "phenotype" (i.e. wild type (1WT) or knock out (3D8)).
```{r eval=FALSE}
#Extract the relevant part of the mass spec run names that points to the phenotype.
pheno <- factor(substr(runs, 1,3))
```

Add a factor for each of the 6 biological replicates (i.e. 3 biological repeats for each phenotype).
```{r eval=FALSE}
#Extract the biological repeat based on the mass spec run names. You can also manually create this vector if this would be easier. Just make sure not to make any mistakes.
n <- nchar(runs)
biorep <- as.factor(paste0("b_",factor(as.numeric(factor(paste0(substr(runs, 1,1),substr(runs, n-2,n-2)))))))
```

Each of the 18 technical repeats are here represented by the 18 mass spec runs.

Create an experiment annotation data frame.
```{r eval=FALSE}
exp_annotation <- data.frame(run=runs, pheno=pheno, biorep=biorep)
exp_annotation
```

###2.2. Preprocess the data using the preprocess_MaxQuant function.

The identification of peptides that carry one or more chemical modifications is often not as reliable as the identification of unmodified peptides. Therefore, a common step during the preprocessing of proteomics data consists of removing the proteins of which all identified peptides have one or more modification sites. If we want to remove these proteins that are only identified by modified peptides from the dataset, we also need the proteinGroups.txt file. This file can be found in the same location as the peptides.txt file ("path_to_raw_files/combined/txt/proteinGroups.txt"). Here, we make use of the proteinGroups.txt file that is delivered with the package.

**Note:** if you don't want to remove proteins that are only identified by modified peptides, set the `remove_only_site` argument of the `preprocess_MaxQuant` function to `FALSE` and leave the `file_proteinGroups` argument at its default value `NULL`.

Define the path to the proteinGroups.txt file.
```{r eval=FALSE}
file_proteinGroups <- system.file("extdata/Francisella", "proteinGroups.txt", package = "MSqRob")
```

Add to the `useful_properties` argument all column names of the `fData` slot of the peptidesCPTAC `MSnSet` object that you would like to keep (such as gene names, protein names, ontologies, etc.). Other columns will be removed for improved efficiency and memory usage.  Here, we would like to keep the GI number and the protein names. These 2 columns are present in our peptides.txt file, but note that you can use basic R manipulations to add other columns to the fData slot if you want to. We certainly want to keep the "Sequence" slot, as peptide-specific effects must be included in our model.

```{r eval=FALSE}
peptidesFranc2 <- preprocess_MaxQuant(peptidesFranc, accession="Proteins", exp_annotation=exp_annotation, logtransform=TRUE, base=2, normalisation="quantiles", smallestUniqueGroups=TRUE, useful_properties=c("GI_number","Protein.names","Sequence"), filter=c("Contaminant","Reverse"), remove_only_site=TRUE, file_proteinGroups=file_proteinGroups,  filter_symbol="+", minIdentified=2)
```

`preprocess_MaxQuant` internally executes the following preprocessing steps in this order:

1. Peptide intensities are (log2-)transformed (`logtransform=TRUE, base=2`).

2. As a normalization approach, we choose to quantile normalize the peptide intensities (`normalisation="quantiles"`). Other options are `"sum"`, `"max"`, `"center.mean"`, `"center.median"`, `"quantiles.robust"`, `"vsn"` or `"none"` (see `MSnbase::normalise` for more information).

3. Handling overlapping protein groups (`smallestUniqueGroups=TRUE`): in our approach a peptide can map to multiple accessions (`accession="Proteins"`), as long as there is none of these proteins present in a smaller subgroup. Peptides that map to protein groups for wich also subgroups are present in the dataset are removed from the dataset. (Proteins in a protein group are separated by a `;`).

4. Remove contaminants and reverse sequences (`filter=c("Contaminant","Reverse"), filter_symbol="+"`): each row with the filter symbol ("+" in our case) in the columns "Contaminant" and "Reverse" will be removed from the data. Note that the "Contaminant" column in older MaxQuant peptides.txt files can also be called "Potential.contaminant".

5. Remove all proteins that are only identified by peptides carrying a modification site (`remove_only_site=TRUE`, `file_proteinGroups=file_proteinGroups`).

6. Remove all superfluous columns in the `fData` slot, except the "Proteins", "GI_number", "Protein.names" and "Sequence" columns (`useful_properties=c("GI_number","Protein.names","Sequence")`). Note that the "Proteins" column does not have to be provided: the `accession` column is always retained.

7. Remove all peptides that are only identified once in the dataset (`minIdentified=2`).

8. Add experiment annotation (`exp_annotation=exp_annotation`).

###3. Convert the MSnSet object peptidesFranc2 into a protdata object proteinsFranc.

**Caution:** this step might take some time! (almost 2 minutes on our system).
The `accession` argument denotes by which column the individual peptide observations should be grouped. The `annotations` argument indicates which columns in peptidesFranc2 are annotations linked to the accessions (in our case: the GI number and the protein names). These annotations will be added to a separate `annotation` slot.
```{r eval=FALSE}
system.time(proteinsFranc <- MSnSet2protdata(peptidesFranc2, accession="Proteins", annotations = c("GI_number", "Protein.names")))
proteinsFranc
```

The `system.time` function is only used here to print out how long the operation lasted. If you are not interested in that, you can of course omit this.

```{r eval=FALSE}
#Keep eval=FALSE
proteinsFranc <- MSnSet2protdata(peptidesFranc2, accession="Proteins", annotations = c("GI_number", "Protein.names"))
```

You can also load the data from the data package for comparison.
```{r eval=FALSE}
#data(proteinsFranc, package="MSqRob")  #Data package to be made.
```

###Advanced: add information on the design after creating your protdata object

Imagine you forgot a factor in your experimental annotation. Should you redo the whole preprocessing part? No, often, you can still add this factor thanks to the `addVarFromVar` function. We will now show how we can add an extra (redundant) factor called `techrep`.

Create a factor for each of the 18 technical replicates (each sample was analyzed in triplicate). This factor is completely redundant, as the "run" column in the experimental annotation already has 18 different levels and is thus already equal to the factor for the technical replicates.
```{r eval=FALSE}
techrep <- as.factor(paste0("t_",as.numeric(factor(levels(exp_annotation$run)))))
names(techrep) <- levels(exp_annotation$run)
techrep
proteinsFranc2 <- addVarFromVar(proteinsFranc, basecol="run", name="techrep", vector=techrep)
```

You will be able to load the processed proteins data directly from the future MsqRobData package.
```{r eval=FALSE}
#data(proteinsFranc, package="MsqRobData")
```

###4. Fit the model and squeeze residual the variances

Fit the robust ridge models for each protein. The `fit.model` function will fit a model to each protein in the `protdata` object "proteinsFranc". The default setting `reg="ridge"` indicates that ridge regression should be used. The default setting `weights="Huber"` indicates that an M estimation algorithm should be used that assigns Huber weights to each peptide observation based on their residuals.

Caution: fitting the models takes some time (less than 15 minutes for the *Francisella tularensis* dataset on our system). The `system.time` function was again only added to output the duration of the model fitting.
```{r eval=FALSE}
system.time(protLMFranc <- fit.model(proteinsFranc, response="quant_value", fixed=c("pheno"),  random=c("biorep","run","Sequence"), add.intercept=TRUE, weights="Huber"))
```

Then, we squeeze the residual variances of our model.
```{r eval=FALSE}
protLMFranc <- squeezePars(protLMFranc)
```

You will be able to load the resulting `protLM` object "protLMFranc" from the future MsqRobData package.
```{r eval=FALSE}
#data(protLMFranc, package="MsqRobData")
```

###4.1. Inspect the model

`protLMFranc` is a `protLM` object.
```{r eval=FALSE}
class(protLMFranc)
```

Printing out a `protLM` object returns an overview of the first 6 accessions with their annotations and their corresponding models.
```{r eval=FALSE}
protLMFranc
```

The numbers in the `Std.Dev.` column give the estimated standard deviations of the random effects. Effects starting with `ridgeGroup.` indicate shrunken fixed effects (we make use of the random effects framework of the `lm4` package in order to estimate Ridge penalties). However, as the fixed effects in the ridgeGroups are orthogonalized using the Gramm-Schmidt procedure, these numbers are not very informative.

A `protLM` object contains three slots:

1. an `accession` slot: a vector containing all the accessions
2. a `model` slot: a list of all fitted models (one for each accession)
3. an `annotation` slot: data frame of which each row (one for each accession) corresponds to the annotations of a different accession.

These slots can be accessed using the `getAccessions`, `getModels` and `getAnnotations` functions respectively. Here we give the accessions, models and annotations for the first 5 models.

```{r eval=FALSE}
getAccessions(protLMFranc)[1:5]
getModels(protLMFranc)[1:5]
getAnnotations(protLMFranc)[1:5,]
```

`protLM` objects can be subsetted using either their numeric index or their corresponding accession.

Retain only the part corresponding to model 24 and model 50.
```{r eval=FALSE}
protLMFranc[c(24,50)]
```

Inspect the `protLM` object corresponding to accession "WP_003033643".
```{r eval=FALSE}
protLMFranc["WP_003033643"]
```

Say we want to inspect cell division protein "WP_003040227". We can then select protein "WP_003040227" from the `protLM` object. We can extract the model via the `getModels` function. `simplify=TRUE` is the default setting and indicates that if you select one model, you only want this model and not a list with as only element this model. Note that if you select multiple models, you automatically receive a list of models.

```{r eval=FALSE}
modelWP_003040227 <- getModels(protLMFranc["WP_003040227"], simplify=TRUE)
modelWP_003040227
```

The `betaBVcovDf` function extracts a list from a model containing the following four elements:

1. beta: the estimated parameters: both fixed effect sizes and BLUPs (best linear unbiased predictors) for the random effects
2. vcov: the variance-covariance matrix
3. df: the residual degrees of freedom
4. df: the residual degrees of freedom
5. sigma: the residual standard deviation

```{r eval=FALSE}
betaBVcovDf <- getBetaVcovDf(modelWP_003040227)
```

```{r eval=FALSE}
betaBVcovDf$beta
betaBVcovDf$vcov
betaBVcovDf$df
betaBVcovDf$df_exp
betaBVcovDf$sigma
```

The `getBetaVcovDfList` function can be applied on (a subset of) the `protLM` object `protLMFranc`. This returns a list containing one or more lists similar to the `betaBVcovDf` list.

```{r eval=FALSE}
betaVcovDfList <- getBetaVcovDfList(protLMFranc[1:2])
str(betaVcovDfList)
```

###5. Statistical inference

We are interested in which proteins differ significantly in abundance between ArgP mutant and wild type *Francisella tularensis*. Via the "MSqRob_levels" attribute, you can check which factor levels are present in each model. Pick a model for which there are no missing levels for the factors for which you want to test contrasts and inspect the names. Note that these names are always the combination of the parameter name and the factor level.

```{r eval=FALSE}
attr(modelWP_003040227,"MSqRob_levels")
```

Here, we notice that the mutant is encoded as "pheno3D8" and the wild type as "pheno1WT". We construct a contrast matrix L for inferring on the fold change of interest. We are interested in the log2 fold change between mutant and wild type. As all intensities are log2-transformed, we should take the difference between "pheno3D8" and "pheno1WT" (because of the following property of logarithms: log2(a/b)=log2(a)-log2(b)).
```{r eval=FALSE}
L <- makeContrast(contrasts=c("pheno3D8-pheno1WT"),
                  levels=c("pheno1WT","pheno3D8"))
L
```

Imagine we would want to test the average log2 protein intensity between mutant and wild type, then L would be constructed as follows:
```{r eval=FALSE}
#Keep eval=FALSE
L <- makeContrast(contrasts=c("pheno3D8/2+pheno1WT/2"),
                  levels=c("pheno1WT","pheno3D8"))
L
```

**Important notification:** do not use the estimated parameters beta to determine the factor levels! You will notice for example that the level "pheno1WT" is missing in the column names of the betas. This is because "pheno1WT" is the reference class, giving the parameter corresponding to "pheno3D8" the interpretation of the effect of "pheno3D8" relative to "pheno1WT". It is important however to include "pheno1WT" in the contrast matrix because for proteins where factor levels are missing, these parameters can get different interpretations. The `makeContrast` function takes this into account and will return `NA` when a contrast cannot be properly estimated.

```{r eval=FALSE}
betaBVcovDf$beta
```

Build a data frame containing estimate, standard error, degrees of freedom, T-value and p-value for each protein in the `protLM` object protLMFranc, by using the `test.protLMcontrast` function.
```{r eval=FALSE}
resultFranc <- test.protLMcontrast(protLMFranc, L, min_df=1)
```

The `prot.p.adjust` function adds a new column "qval" to the data frame based on an existing "pval" column. The new column contains adjusted p-values using one of the methods in the `p.adjust.methods` vector.
```{r eval=FALSE}
resultFranc <- prot.p.adjust(resultFranc, method="fdr")
```

The `prot.signif` function needs a matrix (or a list of matrices) containing a column named "pval" and a column named "qval". The "pval" column will be used to sort the matrix. The function generates a new column "signif" containing 1 for all values of "qval" with a value lower than the specified FDR level (default: 0.05) and 0 otherwise.
```{r eval=FALSE}
resultFranc <- prot.signif(resultFranc, level = 0.05)
```

###Advanced: importing as a data frame

It is also possible to import your data as a simple data frame and make use of some custom preprocessing pipeline. Here, we will show the same preprocessing pipeline for the *Francisella* dataset as outlined above, but note that adding, removing or modifying steps in the preprocessing pipeline is now very simple as the data is in data frame format.

First, we import the *Francisella* dataset as a data frame via the base R function `read.table`.

```{r eval=FALSE}
pepFrancDf <- read.table(file = file_peptides_txt, sep = "\t", header = TRUE, quote="", comment.char = "")
```

Of course, other filetypes can also be imported. Say for example your input file is a comma separated file stored in My Documents on a Windows computer, you could use for example:

```{r eval=FALSE} 
#keep eval=FALSE
pepFrancDf <- read.table("C:/Users/Ludger/Documents/peptides.csv", sep = ",", dec=".", header = TRUE, quote="", comment.char = "")
```

The data frame `pepFrancD` is in wide format.

```{r eval=FALSE} 
head(pepFrancDf)
```

**Exceptional:** as explained higher on, the dataset contains more data than we need. Normally, it is not good practise to just remove data from your experiment. Even if you don't want to use a certain part of your data, it might still be a good idea to keep it into your model (because more data often means better variance estimates). However, in this tutorial, we remove this data in order to speed things up.

```{r eval=FALSE} 
#Experiments we want to keep
keep <- c("Intensity.1WT_20_2h_n3_1", "Intensity.1WT_20_2h_n3_2", "Intensity.1WT_20_2h_n3_3",
"Intensity.1WT_20_2h_n4_1", "Intensity.1WT_20_2h_n4_2", "Intensity.1WT_20_2h_n4_3",
"Intensity.1WT_20_2h_n5_1", "Intensity.1WT_20_2h_n5_2", "Intensity.1WT_20_2h_n5_3",
"Intensity.3D8_20_2h_n3_1", "Intensity.3D8_20_2h_n3_2", "Intensity.3D8_20_2h_n3_3",
"Intensity.3D8_20_2h_n4_1", "Intensity.3D8_20_2h_n4_2", "Intensity.3D8_20_2h_n4_3",
"Intensity.3D8_20_2h_n5_1", "Intensity.3D8_20_2h_n5_2", "Intensity.3D8_20_2h_n5_3")

#Indices of columns of experiments we want to remove
remove_experiments <- which(grepl("Intensity.", colnames(pepFrancDf)) & !(colnames(pepFrancDf) %in% keep))

#Remove experiments we are not interested in
pepFrancDf <- pepFrancDf[,-remove_experiments]
#Remove "remove_experiments" fromt the global environment in order to prevent accidental double execution of the code line above.
rm(remove_experiments)
```

If we want to mimick the MaxQuant preprocessing pipeline, we need to add a factor that indicates whether a protein is only identified by modified peptides. This requires some basic R programming. The information about which proteins are only identified by modified peptides can be found in the proteinGroups.txt file. We again make use of the proteinGroups.txt file that is delivered with the package.

```{r eval=FALSE} 
#Import the proteinGroups.txt file delivered with the package 
file_proteinGroups <- system.file("extdata/Francisella", "proteinGroups.txt", package = "MSqRob")
  proteinGroups <- read.table(file_proteinGroups, sep="\t", header=TRUE, quote="", comment.char = "")
  #Extract the column that indicates which proteins are only identified by a modification site
  only_site <- proteinGroups$Only.identified.by.site
  #If there are no such proteins (as is the case here), the column will be completely empty and R will import this by default as "NA". However, we want the an empty value instead of "NA" to keep this column consistent with the "Contaminant" and "Reverse" columns.
  only_site[is.na(only_site)] <- ""
  #Select the protein accessions that are only identified by one or more modified peptides
  removed_proteins <- proteinGroups$Protein.IDs[only_site==filter_symbol]

  #Create logical "rem" that holds "TRUE" if a row in the pepFrancDf data frame should be removed and FALSE otherwise.
  rem <- as.character(pepFrancDf[,accession]) %in% as.character(removed_proteins)
  #Create a new column "only_site" in "pepFrancDf" that indicates with a "+" which rows should be removed.
  pepFrancDf$only_site <- ""
  pepFrancDf$only_site[rem] <- "+"
```

Note that in this particular case, the previous chunck of code was superfluous, as there are no proteins in the dataset that are only identified by modified peptides.

We can easily preprocess the data frame using the `preprocess_wide` function (for data in "long" format, use the `preprocess_long` function). This function uses our standard preprocessing pipeline on data frames in "wide" format (i.e. the data frame has one observation row per subject with each measurement present as a different variable).

We already made the `exp_annotation` object before (see "2.1. Create experiment annotation data frame."), so we will not repeat this code again here. **Importantly, however, contrary to the `exprs` slot in the `peptidesFranc2` object created before, the names of all intensity columns in data frame `pepFrancDf` start with "Intensity.".**

**This is because the default setting `remove_pattern=TRUE` in the `read_MaxQuant` function removes the prefix "Intensity." from the columns containing the intensities as this allows users that are unfamiliar with R to just copy and paste their experiment names from their MaxQuant input.** We thus need to add the "Intensity." prefix to the previously created `exp_annotation` data frame. We choose to create a new experimental annotation data frame called `exp_annotation2`.

```{r eval=FALSE} 
exp_annotation2 <- exp_annotation
exp_annotation2[,"run"] <- as.factor(paste0("Intensity.",as.character(exp_annotation2[,"run"])))
```

The `preprocess_wide` function allows for the same preprocessing as the `preprocess_MaxQuant` function on a regular data frame. If you inspect this function, you will notice that the same 8 preprocessing steps are executed. Remember that you can do any preprocessing you like using basic R data frame manipulations. This `split` argument indicates which character string is used to separate the accession groups. The `exp_annotation` argument, like before, contains the experimental annotation data frame or a character string indicating the filepath where the experimental annotation is saved as an Excel file or a tab-delimited file. The `quant_cols` argument contains a vector of names or a vector of numeric indices pointing to the columns containing the quantitative values of interest (mostly intensities or areas under the curve). If `quant_cols` contains only one character string, each column containing this pattern will be regarded as a column containing the quantitative values of interest. `aggr_by` indicates the column by which the data should be aggregated. Here, the data is already aggregated to the peptide level (i.e. over different charge states and modification statuses). We need no further aggregation, thus we provide the "Sequence" column (the level to which aggregation has already been done). `aggr_function` will be superfluous here, but if further aggregation would have been necessary, raw intensities would be summed up (`aggr_function="sum"`). The other parameters are similar to the `preprocess_MaxQuant` function.

```{r eval=FALSE} 
pepFrancDf2 <- preprocess_wide(pepFrancDf, accession="Proteins", split=";", exp_annotation=exp_annotation2, quant_cols="Intensity.", aggr_by="Sequence", aggr_function="sum", logtransform=TRUE, base=2, normalisation="quantiles", smallestUniqueGroups=TRUE, useful_properties=c("GI_number","Protein.names","Sequence"), filter=c("Contaminant","Reverse","only_site"), filter_symbol="+", minIdentified=2)
```

Note that the experimental annotation is now present as an attribute of the `pepFrancDf2` data frame.

```{r eval=FALSE} 
attr(pepFrancDf2,"MSqRob_exp_annotation")
```

After custom preprocessing, you can transform the data to a `protdata` object via the `df2protdata` function.

The `acc_col` argument in the `df2protdata` function indicates the column index or column name of the accessions (i.e. the protein (group) identifiers). The `quant_cols` argument is a vector of indices pointing to all columns containing peptide intensities. In the example below, the column named "Proteins" will be added to the `accession` slot while all columns with indices in the `quant_cols` vector will be added as a matrix to the `intensities` slot. `quant_name` indicates the name that will be given to the column containing the (preprocessed) intensities and `run_name` indicates the name that will be given to the column containing the mass spec run names in the new `protdata` object. Like before, we keep "GI_number" and "Protein.names" as annotations.

```{r eval=FALSE}
#Select columns with intensities.
quant_cols <- which(grepl("Intensity.", colnames(pepFrancDf2)))
quant_cols
```


```{r eval=FALSE}
#Call df2protdata function
proteinsFrancDf <- df2protdata(pepFrancDf2, acc_col="Proteins", quant_cols=quant_cols, quant_name="quant_value", run_name="run", annotations=c("GI_number","Protein.names"))
#Inspect proteinsFrancDf protdata object.
proteinsFrancDf
```

Note that the `proteinsFrancDf` object is the same as the `proteinsFranc` object, only with a different order of columns in their `data` slot.

## CPTAC dataset (data-dependent, label-free)

```{r eval=FALSE}
library(MSqRob)
library(Biobase)
```

This example involves the CPTAC Study 6. In this dataset Sigma's UPS1 standard containing 48 human proteins was spiked into a reference yeast proteome and analyzed on 7 instruments in 5 different laboratories (Paulovich et al., 2010). Raw data files can be downloaded at:
https://cptac-data-portal.georgetown.edu/cptac/dataPublic/list?currentPath=%2FPhase_I_Data%2FStudy6&nonav=true

Here, we limited ourselves to the data of LTQ-Orbitrap at site 86, LTQ-Orbitrap O at site 65 and LTQ-Orbitrap W at site 56. The data was searched with MaxQuant version 1.5.2.8. Detailed search settings can be found in Goeminne et al. (2016).

###1. Import MaxQuant's peptides.txt file

First, specify the location of the peptides.txt MaxQuant output file.
By default, MaxQuant creates a "combined" folder in the same folder as the raw files are (or if the raw files are in different directories, in the directory of the first raw file). The peptides.txt file can then be found in "path_to_raw_files/combined/txt/peptides.txt". Here, we make use of the peptides.txt file that is delivered with the package.

```{r eval=FALSE}
file_peptides_txt <- system.file("extdata/CPTAC", "peptides.txt", package = "MSqRob")
```

Import MaxQuant's peptides.txt file and convert it to an `MSnSet` object (see package `MSnbase`).
```{r eval=FALSE}
peptidesCPTAC <- read_MaxQuant(file_peptides_txt, pattern="Intensity.", remove_pattern=TRUE)
```

The "pattern" argument indicates which columns in the peptides.txt file contain peptide intensities. Currently, all columns containing "Intensity." in their column names will be treated as peptide intensities (default for MaxQuant). `remove_pattern=TRUE` (default) indicates that the name of the pattern is removed from the column names.

###2. Preprocessing

###2.1. Add information on the design: create experimental annotation data frame.

Extract the names of the mass spec runs via the `sampleNames` function from the `Biobase` package.
```{r eval=FALSE}
runs <- sampleNames(peptidesCPTAC)
```

Add a grouping factor for the spike-in condition (i.e. 6A, 6B, 6C, 6D and 6E).
```{r eval=FALSE}
conc <- factor(substr(runs, 1,2))
```

Add a grouping factor for each of the 9 technical repeats (i.e. instrument x run).
```{r eval=FALSE}
rep <- factor(substr(runs, 4,4))
```

Add a grouping factor for the instrument effect (i.e. LTQ-Orbitrap at site 86, LTQ-Orbitrap O at site 65 and LTQ-Orbitrap W at site 56).
```{r eval=FALSE}
instrlab <- factor((as.numeric(rep)-1)%/%3+1)
```

Create an experiment annotation data frame.
```{r eval=FALSE}
exp_annotation <- data.frame(run=runs, conc=conc, rep=rep, instrlab=instrlab)
exp_annotation
```

Remember that the `exp_annotation` can also be given as an Excel file or a tab delimited file!

###2.2. Preprocess the data using the preprocess_MaxQuant function.

If we want to remove proteins that are only identified by modified peptides from the dataset, we also need the proteinGroups.txt file. This file can be found in the same location as the peptides.txt file ("path_to_raw_files/combined/txt/proteinGroups.txt"). Here, we make use of the proteinGroups.txt file that is delivered with the package.

Note: if you don't want to remove proteins that are only identified by modified peptides, set `remove_only_site=FALSE` and leave the `file_proteinGroups` argument at its default value (`NULL`).

```{r eval=FALSE}
file_proteinGroups <- system.file("extdata/CPTAC", "proteinGroups.txt", package = "MSqRob")
```

**Important:** in the CPTAC dataset, some human UPS proteins are NOT contaminants as these proteins were spiked in on purpose! We only want to remove those contaminants that are not human UPS proteins. We thus need to unmark these proteins as contaminant before preprocessing.
```{r eval=FALSE}
fData(peptidesCPTAC)[grepl("_HUMAN_UPS", fData(peptidesCPTAC)$Proteins),]$Potential.contaminant <- ""
```

Add to `useful_properties` all column names of the `fData` slot of the peptidesCPTAC `MSnSet` object that you would like to keep (such as gene names, protein names, ontologies, etc.). Other columns will be removed for improved efficiency and memory usage. We certainly want to keep the "Proteins" slot, as this will be our protein (group) identifier. You also want to keep the "Sequence" slot, as peptide-specific effects must be included in our model.

```{r eval=FALSE}
peptidesCPTAC2 <- preprocess_MaxQuant(peptidesCPTAC, accession="Proteins", exp_annotation=exp_annotation, logtransform=TRUE, base=2, normalisation="quantiles", smallestUniqueGroups=TRUE, useful_properties=c("Proteins","Sequence"), filter=c("Potential.contaminant","Reverse"), remove_only_site=TRUE, file_proteinGroups=file_proteinGroups, filter_symbol="+", minIdentified=2)
```

The following preprocessing steps are executed in this order:

1. Peptide intensities are log2-transformed (`logtransform=TRUE, base=2`).

2. As a normalization approach, we choose to quantile normalize the peptide intensities (`normalisation="quantiles"`). Other options are `"sum"`, `"max"`, `"center.mean"`, `"center.median"`, `"quantiles.robust"`, `"vsn"` or `"none"` (see `MSnbase::normalise` for more information).

3. Handling overlapping protein groups (`smallestUniqueGroups=TRUE`): in our approach a peptide can map to multiple proteins, as long as there is none of these proteins present in a smaller subgroup. Peptides that map to protein groups for wich also subgroups are present in the dataset are removed from the dataset.

4. Remove reverse sequences and contaminants (`filter=c("Potential.contaminant","Reverse")`).

5. Remove all proteins that are only identified by peptides carrying a modification site (`remove_only_site=TRUE`, `file_proteinGroups=file_proteinGroups`).

6. Remove all superfluous columns in the fData slot, except the "Proteins" and "Sequence" columns (`useful_properties=c("Proteins","Sequence")`).

7. Remove all peptides that are only identified once in the dataset (`minIdentified=2`).

8. Add experiment annotation.

###2.3. Advanced alternative: do the preprocessing yourself.

It is possible to do all the preprocessing steps yourself. That way, you can do more advanced preprocessing or change the order of certain preprocessing steps if you like to.

1. Log2-transform the peptide intensities.
```{r eval=FALSE}
peptidesCPTAC3 <- log(peptidesCPTAC, base=2)
#Alternative: 
#peptidesCPTAC3 <- log2(peptidesCPTAC3)
```

After log2-transformation, we want to replace `-Inf` values in the peptide intensities by `NA` values as these values originate from zeros in the untransformed `intensities` matrix, which means these intensities were actually missing.
```{r eval=FALSE}
exprs <- exprs(peptidesCPTAC3)
exprs[is.infinite(exprs)] <- NA
exprs(peptidesCPTAC3) <- exprs
```

2. As a normalization approach, we choose to quantile normalize the peptide intensities.
```{r eval=FALSE}
peptidesCPTAC3 <- normalise(peptidesCPTAC3, "quantiles")
```

3. Handling overlapping protein groups: in our approach a peptide can map to multiple proteins,
as long as there is none of these proteins present in a smaller subgroup.
```{r eval=FALSE}
groups2 <- smallestUniqueGroups(fData(peptidesCPTAC3)$Proteins)
sel <- fData(peptidesCPTAC3)$Proteins %in% groups2
peptidesCPTAC3 <- peptidesCPTAC3[sel]
head(fData(peptidesCPTAC3))
```

4. Remove reverse sequences and contaminants.
```{r eval=FALSE}
#Remove reverse sequences
sel <- fData(peptidesCPTAC3)$Reverse != "+"
peptidesCPTAC3 <- peptidesCPTAC3[sel]
head(exprs(peptidesCPTAC3))

#Remove contaminants
sel <- fData(peptidesCPTAC3)$Potential.contaminant != "+"
peptidesCPTAC3 <- peptidesCPTAC3[sel]
head(exprs(peptidesCPTAC3))
```

<!-- More advanced, mostly not necessary in a standard analysis: add a UPS-indicator to the properties slot of the peptides object. -->
<!-- ```{r eval=FALSE} -->
<!-- fData(peptidesCPTAC3)$ups <- as.double(grepl("_HUMAN_UPS", fData(peptidesCPTAC3)$Proteins)) -->
<!-- ``` -->

Small check:
```{r eval=FALSE}
length(unique(fData(peptidesCPTAC3)$Proteins[grepl('_HUMAN_UPS',fData(peptidesCPTAC3)$Proteins)]))
```
46 out of a total 48 spiked-in human UPS proteins are present in this dataset with at least one peptide sequence identified.

5. Remove proteins that are only identified by modified peptides.
```{r eval=FALSE}
  proteinGroups <- read.table(file_proteinGroups, sep="\t", header=TRUE, quote="", comment.char = "")
  only_site <- proteinGroups$Only.identified.by.site
  only_site[is.na(only_site)] <- ""
  removed_proteins <- proteinGroups$Protein.IDs[only_site=="+"]

  sel <- !(as.character(Biobase::fData(peptidesCPTAC3)[,"Proteins"]) %in% as.character(removed_proteins))
  peptidesCPTAC3 <- peptidesCPTAC3[sel]
```

6. Retain only those properties in the properties slot that are useful for our further analysis.
```{r eval=FALSE}
fData(peptidesCPTAC3) <- fData(peptidesCPTAC3)[,c("Proteins","Sequence")] #, "ups"
```

7. How many times shoud a peptide be identified in order to keep it in the dataset? We require at least 2 identifications of a peptide sequence, as with 1 identification, the models will be perfectly confounded.
```{r eval=FALSE}
minIdentified <- 2
keepers <- rowSums(!is.na(exprs(peptidesCPTAC3)))>=minIdentified
peptidesCPTAC3 <- peptidesCPTAC3[keepers]
head(exprs(peptidesCPTAC3))
```

8. Add the experimental design to the MSnSet object.
```{r eval=FALSE}
pData(peptidesCPTAC3) <- exp_annotation
```

You will be able to load the preprocessed peptide data directly from the future MsqRobData package via the following command.
```{r eval=FALSE}
#data(peptidesCPTAC3, package="MSqRobData") #Data package to be made.
```

```{r eval=FALSE}
all(exprs(peptidesCPTAC2)==exprs(peptidesCPTAC3), na.rm=TRUE)
all(fData(peptidesCPTAC2)==fData(peptidesCPTAC3), na.rm=TRUE)
all(pData(peptidesCPTAC2)==pData(peptidesCPTAC3), na.rm=TRUE)
```

###3. Convert the MSnSet object peptidesCPTAC2 into a protdata object proteinsCPTAC.

**Caution:** this step might take some time! (5 - 10 minutes on our system).
The accession element denotes by which column the individual peptide observations should be grouped.
```{r eval=FALSE}
system.time(proteinsCPTAC <- MSnSet2protdata(peptidesCPTAC2, accession="Proteins"))
```

You will be able to load the data from the future MsqRobData package for comparison.
```{r eval=FALSE}
#data(proteinsCPTAC, package="MsqRobData")  #Data package to be made.
```

###4. Main Analysis

Caution: model fitting takes some time with large datasets! On our computer, fitting the robust ridge model took about 13 minutes.

**Note:** in order to do an objective comparison between different approaches, we chose here not to include the "run" effect, because this leads to massive overfitting in the ordinary least squares approaches. This effect will mostly be equal to zero anyways because each repeat in the CPTAC dataset is in fact a technical repeat and therefore the variability in peptide intensities between samples will be very small. When doing a standard robust ridge analysis on true biological data, we advise however to include the "run" effect as a random effect.

Fit the robust ridge model
```{r eval=FALSE}
system.time(modelRRCPTAC <- fit.model(protdata=proteinsCPTAC, response="quant_value", fixed="conc", random=c("Sequence","instrlab"), add.intercept=TRUE, shrinkage.fixed=NULL, weights="Huber", k = 1.345, tolPwrss = 1e-10, verbose=FALSE))
```

Fit a ridge model without M estimation with Huber weights.
```{r eval=FALSE}
system.time(modelRidgeCPTAC <- fit.model(protdata=proteinsCPTAC, response="quant_value", fixed="conc", random=c("Sequence","instrlab"), add.intercept=TRUE, shrinkage.fixed=NULL, weights=NULL, k = 1.345, tolPwrss = 1e-10, verbose=FALSE))
```

Fit an OLS model with M estimation with Huber weights.
```{r eval=FALSE}
system.time(modelLmMCPTAC <- fit.model(protdata=proteinsCPTAC, response="quant_value", fixed=c("conc","Sequence","instrlab"), random=NULL, add.intercept=TRUE, shrinkage.fixed=c(0,0,0), weights="Huber", k = 1.345, tolPwrss = 1e-10, verbose=FALSE))
```

Fit an OLS model without M estimation with Huber weights.
```{r eval=FALSE}
system.time(modelLmCPTAC <- fit.model(protdata=proteinsCPTAC, response="quant_value", fixed=c("conc","Sequence","instrlab"), random=NULL, add.intercept=TRUE, shrinkage.fixed=c(0,0,0), weights=NULL, k = 1.345, tolPwrss = 1e-10, verbose=FALSE))
```

You will be able to load the data from the future MsqRobData package for comparison.
```{r eval=FALSE}
#data(modelRRCPTAC, package="MsqRobData") #Data package to be made.
```

###4.1. Inspect the model

```{r eval=FALSE}
attr(getModels(modelRRCPTAC[1]),"MSqRob_levels")
```

MSqRob always tries to fit a model, but some models are overparameterized because too many parameters are fit on too few observations. These models have convergence problems and can be removed from the data prior to estimating p-values. This is only relevant for models that perform shrinkage or use any kind of random effect.

Extract the data as a list from the protdata object `proteinsCPTAC`.
```{r eval=FALSE}
data <- getData(proteinsCPTAC)
```

###4.2. Avanced and optional: check which models would fail to converge by building a linear mixed effects model.

```{r eval=FALSE}
convergence <- lapply(data, function(x){return(tryCatch(lme4::lFormula(formula("quant_value~1+(1|conc)+(1|instrlab)+(1|Sequence)"),x,control = lme4::lmerControl()), error=function(e){
  return(NA)
}))})
```

Get the indices of these overparameterized models.
```{r eval=FALSE}
na_indices <- which(is.na(convergence))
```

See which proteins you removed.
```{r eval=FALSE}
getAccessions(proteinsCPTAC)[na_indices]
```

Both UPS proteins in this list are only identified by one peptide.
```{r eval=FALSE}
getData(proteinsCPTAC["P69905ups|HBA_HUMAN_UPS"])
getData(proteinsCPTAC["P41159ups|LEP_HUMAN_UPS"])
```

Remove the overparameterized models from the protLM object `modelRRCPTAC` and from the data.
```{r eval=FALSE}
modelRRCPTAC <- modelRRCPTAC[-na_indices]
data <- data[-na_indices]
```

###5. Statistical inference

Construct the contrast matrix L for inferring on the fold changes of interest
```{r eval=FALSE}
L <- makeContrast(c("conc6B-conc6A","conc6C-conc6A","conc6D-conc6A","conc6E-conc6A","conc6C-conc6B","conc6D-conc6B","conc6E-conc6B","conc6D-conc6C","conc6E-conc6C","conc6E-conc6D"),
                  c("conc6A","conc6B","conc6C","conc6D","conc6E"))
```

Make the DA rankings for the ordinary least squares model (no ridge, no squeezed variances, no M estimation).
```{r eval=FALSE}
modelLmCPTAC <- squeezePars(modelLmCPTAC, squeezeVar=FALSE, robust_var=TRUE)
lm_normal <- test.protLMcontrast(modelLmCPTAC, L, min_df=1, simplify=TRUE)
lm_normal <- prot.p.adjust(lm_normal)
lm_normal <- prot.signif(lm_normal)
```

Make the DA rankings for the ordinary least squares model with squeezed variances (no ridge, no M estimation).
```{r eval=FALSE}
modelLmCPTAC <- squeezePars(modelLmCPTAC, squeezeVar=TRUE, robust_var=TRUE)
lm_Sq <- test.protLMcontrast(modelLmCPTAC, L, min_df=1, simplify=TRUE)
lm_Sq <- prot.p.adjust(lm_Sq)
lm_Sq <- prot.signif(lm_Sq)
```

Make the DA rankings for the ordinary least squares model with squeezed variances and M estimation (no ridge).
```{r eval=FALSE}
modelLmMCPTAC <- squeezePars(modelLmMCPTAC, squeezeVar=TRUE, robust_var=TRUE)
lm_SqM <- test.protLMcontrast(modelLmMCPTAC, L, min_df=1, simplify=TRUE)
lm_SqM <- prot.p.adjust(lm_SqM)
lm_SqM <- prot.signif(lm_SqM)
```

Make the DA rankings for the ridge regression model (no squeezed variances, no M estimation).
```{r eval=FALSE}
modelRidgeCPTAC <- squeezePars(modelRidgeCPTAC, squeezeVar=FALSE, robust_var=TRUE)
ridge <- test.protLMcontrast(modelRidgeCPTAC, L, min_df=1, simplify=TRUE)
ridge <- prot.p.adjust(ridge)
ridge <- prot.signif(ridge)
```

Make the DA rankings for the ridge regression model with squeezed variances (no M estimation).
```{r eval=FALSE}
modelRidgeCPTAC <- squeezePars(modelRidgeCPTAC, squeezeVar=TRUE, robust_var=TRUE)
ridgeSq <- test.protLMcontrast(modelRidgeCPTAC, L, min_df=1, simplify=TRUE)
ridgeSq <- prot.p.adjust(ridgeSq)
ridgeSq <- prot.signif(ridgeSq)
```

Make the DA rankings for the ridge regression model with squeezed variances and M estimation. This is our robust ridge (RR) approach.
```{r eval=FALSE}
modelRRCPTAC <- squeezePars(modelRRCPTAC, squeezeVar=TRUE, robust_var=TRUE)
ridgeSqM <- test.protLMcontrast(modelRRCPTAC, L, min_df=1, simplify=TRUE)
ridgeSqM <- prot.p.adjust(ridgeSqM)
ridgeSqM <- prot.signif(ridgeSqM)
```

Our standard approach is to calculate the degrees of freedom via the trace of the Hat matrix. One could as well use custom degrees of freedom, for example in order to work more conservatively
```{r eval=FALSE}
custom_dfs <- sapply(data, function(x){return(length(unique(paste0(x$conc,x$instrlab)))-length(unique(x$conc))-length(unique(x$instrlab))+2-1)})
custom_dfs

ridgeSqM_custom <- test.protLMcontrast(modelRRCPTAC, L, squeezeVar=TRUE, min_df=1, robust_var=TRUE, simplify=TRUE, custom_dfs = custom_dfs)
ridgeSqM_custom <- prot.p.adjust(ridgeSqM_custom)
ridgeSqM_custom <- prot.signif(ridgeSqM_custom)
```


Extra: add a column containing 1 if the corresponding protein is a spiked-in UPS1 protein and 0 if it is a yeast protein.

```{r eval=FALSE}
lm_normal <- lapply(lm_normal, function(x){
  x <- cbind(x,"ups"=grepl("UPS",rownames(x)))
  return(x)
  })

lm_Sq <- lapply(lm_Sq, function(x){
  x <- cbind(x,"ups"=grepl("UPS",rownames(x)))
  return(x)
})

lm_SqM <- lapply(lm_SqM, function(x){
  x <- cbind(x,"ups"=grepl("UPS",rownames(x)))
  return(x)
})

ridge <- lapply(ridge, function(x){
  x <- cbind(x,"ups"=grepl("UPS",rownames(x)))
  return(x)
})

ridgeSq <- lapply(ridgeSq, function(x){
  x <- cbind(x,"ups"=grepl("UPS",rownames(x)))
  return(x)
})

ridgeSqM <- lapply(ridgeSqM, function(x){
  x <- cbind(x,"ups"=grepl("UPS",rownames(x)))
  return(x)
})
```

###6. Create the summary tables "summary_lm" and the like

Custom function for evaluating the performance of all methods on the CPTAC dataset.
```{r eval=FALSE}
makeSummary <- function(CPTACobject, upratio){

  summary_object <- data.frame(bias0=rep(NA, 10),bias1=rep(NA, 10),sd0=rep(NA, 10),sd1=rep(NA, 10),mad0=rep(NA, 10),mad1=rep(NA, 10),RMSE0=rep(NA, 10),RMSE1=rep(NA, 10),TP5proc=rep(NA, 10),FP5proc=rep(NA, 10),TN5proc=rep(NA, 10),FN5proc=rep(NA, 10))

  for(i in 1:10)
  {

    significante <- subset(CPTACobject[[i]], CPTACobject[[i]][,"qval"]<=0.05)
    nonsignificante <- subset(CPTACobject[[i]], CPTACobject[[i]][,"qval"]>0.05)

    waarden3 <- na.omit(CPTACobject[[i]])

    #RMSE
    summary_object$RMSE0[i] <- sqrt(mean(((subset(waarden3, waarden3[,"ups"]==0)[,"estimate"])-0)^2, na.rm=TRUE))
    #bias:
    summary_object$bias0[i] <- mean((subset(waarden3, waarden3[,"ups"]==0)[,"estimate"])-0, na.rm=TRUE)
    #standard deviation:
    summary_object$sd0[i] <- sd((subset(waarden3, waarden3[,"ups"]==0)[,"estimate"]), na.rm=TRUE)
    #mad:
    summary_object$mad0[i] <- mad((subset(waarden3, waarden3[,"ups"]==0)[,"estimate"]), na.rm=TRUE)

    #RMSE
    summary_object$RMSE1[i] <- sqrt(mean(((subset(waarden3, waarden3[,"ups"]==1)[,"estimate"])-upratio[i])^2, na.rm=TRUE))
    #bias:
    summary_object$bias1[i] <- mean((subset(waarden3, waarden3[,"ups"]==1)[,"estimate"])-upratio[i], na.rm=TRUE)
    #standard deviation:
    summary_object$sd1[i] <- sd((subset(waarden3, waarden3[,"ups"]==1)[,"estimate"]), na.rm=TRUE)
    #standard deviation:
    summary_object$mad1[i] <- mad((subset(waarden3, waarden3[,"ups"]==1)[,"estimate"]), na.rm=TRUE)

    #TP:
    summary_object$TP5proc[i] <- sum(significante[,"ups"])
    #FP:
    summary_object$FP5proc[i] <- length(significante[,"ups"])-sum(significante[,"ups"])
    #FN:
    summary_object$FN5proc[i] <- sum(nonsignificante[,"ups"])
    #TN:
    summary_object$TN5proc[i] <- length(nonsignificante[,"ups"])-sum(nonsignificante[,"ups"])

  }

  return(summary_object)
}
```

Create a vector that contains the theoretical log2 fold changes of the spiked-in UPS1 proteins.
```{r eval=FALSE}
upratio <- c(1.565597,3.137504,4.744161,6.321928,1.571906,
             3.178564,4.756331,1.60665,3.18442,1.577767)
```

Create the summary objects.
```{r eval=FALSE}
summary_lm <- makeSummary(lm_normal, upratio)
summary_lmSq <- makeSummary(lm_Sq, upratio)
summary_lmSqM <- makeSummary(lm_SqM, upratio)
summary_ridge <- makeSummary(ridge, upratio)
summary_ridgeSq <- makeSummary(ridgeSq, upratio)
summary_ridgeSqM <- makeSummary(ridgeSqM, upratio)
```

Results
```{r eval=FALSE}
summary_lm
summary_lmSq
summary_lmSqM
summary_ridge
summary_ridgeSq
summary_ridgeSqM
```
